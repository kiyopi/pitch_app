# シンプル相対音感トレーニング - 設計原則書

**作成日**: 2025-07-15  
**目的**: 設計意図の明確化と実装時の必須チェック項目定義  
**重要度**: 🚨 **修正時必須参照**

---

## 🎯 単純化実装の根本目的

### 解決すべき問題
1. **スタートボタンの役割混乱**: マイク初期化とバトン再生が混在
2. **UX不一致**: ユーザーが基音再生タイミングをコントロールできない
3. **複雑な状態管理**: 複数の状態が絡み合う不安定性

### 達成すべき目的
1. **ユーザー体験の一貫性**: スタートボタンは常に「基音再生」の役割のみ
2. **確実な動作**: マイク状態に関係なく、ユーザーが望むタイミングで基音再生
3. **シンプルな状態管理**: 複雑な状態遷移を排除

---

## 📋 不変の設計原則

### 原則1: スタートボタンの純粋性
- **スタートボタン**: 100%基音再生専用、他の処理は一切含まない
- **禁止事項**: マイク初期化、状態変更、非同期待機
- **許可事項**: 基音選択、基音再生、音程測定開始のみ

### 原則2: 事前準備の分離
- **マイク初期化**: ページ読み込み時に完了、ユーザー操作と分離
- **エラー処理**: 事前準備の問題、実行時に影響させない
- **状態管理**: 準備完了後は変更しない

### 原則3: 確実な動作保証
- **スタートボタン**: 常にアクティブ、即座に応答
- **基音再生**: 確実に発音、遅延なし
- **音程検出**: 基音再生後に確実に開始

---

## 🔄 正しい実装フロー

### フェーズ1: 事前準備（ページ読み込み時）
```javascript
// ページ読み込み時に実行される処理
1. マイク許可取得 (getUserMedia)
2. 音程検出初期化 (Pitchy)
3. エラー発生時は専用ダイアログ表示
4. 準備完了後、スタートボタンをアクティブ化
```

### フェーズ2: ユーザー操作（スタートボタン）
```javascript
// スタートボタン押下時の処理
1. 基音選択 (ランダム選択)
2. 基音再生 (Tone.js)
3. 音程測定開始 (リアルタイム検出)
```

### フェーズ3: 音程検出（自動実行）
```javascript
// 基音再生完了後の処理
1. マイク音声をリアルタイム検出
2. 目標音程との比較
3. 正解判定と次の音程への遷移
```

---

## 🚨 修正時の必須チェック項目

### 実装前チェック
- [ ] この修正はスタートボタンの基音再生専用性を保持しているか？
- [ ] この修正はマイク初期化をページ読み込み時に保持しているか？
- [ ] この修正は事前準備とユーザー操作を分離しているか？

### 判断基準
**質問**: 「この修正はスタートボタンの基音再生専用性を保持しているか？」
- **YES** → 実装可能
- **NO** → 設計見直し、再検討必須

### 設計違反の典型例
❌ **やってはいけない実装**:
```javascript
// スタートボタンでマイク初期化（設計違反）
async start() {
    await this.microphone.requestAccess(); // ❌ 設計違反
    await this.pitchDetector.initialize(); // ❌ 設計違反
    this.baseToneManager.playBaseTone();   // ✅ 正しい
}
```

✅ **正しい実装**:
```javascript
// スタートボタンは基音再生のみ
async start() {
    if (!this.isReady) {
        this.showError('マイクの準備ができていません');
        return;
    }
    this.baseToneManager.playBaseTone();   // ✅ 正しい
}
```

---

## 🔍 過去の設計違反事例

### 事例1: 従来パターンの踏襲
**問題**: `full-scale-training.js`の「スタートボタン押下→マイク初期化」を模倣
**原因**: 既存コードの修正として捉え、新しい設計思想を無視
**教訓**: 既存コードは参考程度、新しい設計で一から実装

### 事例2: 技術的問題として捉える錯誤
**問題**: UX設計の問題を技術的バグとして対処
**原因**: 問題の本質（ユーザー体験）を理解していない
**教訓**: 修正前に「なぜこの設計にしたのか」を理解する

### 事例3: 仕様書の軽視
**問題**: 仕様書を読んでも設計意図を理解しない
**原因**: 技術仕様のみに着目、設計思想を無視
**教訓**: 仕様書の「なぜ」を重視する

---

## 📚 修正時の必須参照フロー

### Step 1: 設計原則確認
1. **本書**を読み返し、設計原則を確認
2. **CLAUDE.md**で開発ルール・手順を確認
3. 修正内容が設計原則に適合するか判定

### Step 2: 実装設計
1. 修正内容を設計原則に基づいて設計
2. 実装前に設計をユーザーに確認
3. 承認後に実装開始

### Step 3: 実装完了チェック
1. 実装が設計原則に適合しているか確認
2. スタートボタンの純粋性が保たれているか確認
3. 事前準備とユーザー操作が分離されているか確認

---

## 🎯 成功の定義

### 技術的成功
- マイク許可がページ読み込み時に完了
- スタートボタンが常にアクティブ
- 基音再生が確実に動作

### UX成功
- ユーザーが好きなタイミングで基音を再生可能
- 待機時間やステータス表示がない
- 直感的で予測可能な動作

### 設計成功
- 複雑な状態管理を排除
- 明確な責任分離
- 保守性の高いコード構造

---

## 🔄 継続的改善

### 定期見直し
- 実装完了後に設計原則の有効性を検証
- 新しい問題が発生した場合は原則を更新
- ユーザーフィードバックを設計に反映

### 文書更新
- 設計原則の変更は必ず文書化
- 変更理由と影響範囲を明記
- 全ての関連文書を同期更新

---

## 📋 エラーダイアログ設計方針

### 2025-07-15 設計決定: 標準ダイアログ + 自動リロード

#### 決定経緯
**問題**: 独自エラーダイアログ vs ブラウザ標準ダイアログの選択
**検討結果**: 標準ダイアログ + 自動リロードが最適解

#### 各エラーケースの対応方法

##### 1. マイク不許可 → スタートボタン押下
```javascript
if (confirm('マイクの準備ができていません。\n\nページを再読み込みしてマイクを許可しますか？')) {
    location.reload();
}
```

##### 2. マイクアクセス拒否時（初期化時）
```javascript
alert('マイクの使用が許可されていません。\n\nブラウザの設定でマイクアクセスを許可してから、ページを再読み込みしてください。');
```

##### 3. マイクが見つからない
```javascript
if (confirm('マイクが見つかりません。\n\nマイクを接続してから再読み込みしますか？')) {
    location.reload();
}
```

#### 標準ダイアログ選択理由

**✅ メリット**:
- **確実な表示**: 必ず表示される
- **シンプル**: 実装が簡単
- **直感的**: ユーザーに馴染みがある
- **リロード対応**: `confirm()` + `location.reload()` で自動化

**❌ デメリット**:
- **デザイン統一性**: アプリと異なる見た目
- **モバイルUX**: 若干の違和感
- **詳細情報**: 長文表示に限界

#### 設計判断基準
**優先順位**: 確実性 > デザイン統一性
**理由**: エラー状況では機能性が最優先

#### 修正時の必須チェック
- [ ] エラーダイアログは標準ダイアログを使用しているか？
- [ ] confirm()でリロード選択肢を提供しているか？
- [ ] エラーメッセージは簡潔で分かりやすいか？

---

**🚨 重要**: この設計原則書は、**修正時に必ず参照する**必須文書です。  
**設計違反は品質低下の直接原因**となるため、例外なく遵守してください。

---

*最終更新: 2025-07-15*  
*次回更新: 実装完了後の設計検証時*